package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

// Group represents a row from 'public.groups'.
type Group struct {
	ID                  int64           `json:"id"`                     // id
	PackageSize         int             `json:"package_size"`           // package_size
	QuestionsTypes      pq.GenericArray `json:"questions_types"`        // questions_types
	Timer               int             `json:"timer"`                  // timer
	NextQuestionOnTimer bool            `json:"next_question_on_timer"` // next_question_on_timer
	EarliestYear        sql.NullInt64   `json:"earliest_year"`          // earliest_year
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Group exists in the database.
func (g *Group) Exists() bool {
	return g._exists
}

// Deleted returns true when the Group has been marked for deletion from
// the database.
func (g *Group) Deleted() bool {
	return g._deleted
}

// Insert inserts the Group to the database.
func (g *Group) Insert(ctx context.Context, db DB) error {
	switch {
	case g._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case g._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.groups (` +
		`id, package_size, questions_types, timer, next_question_on_timer, earliest_year` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)`
	// run
	logf(sqlstr, g.ID, g.PackageSize, g.QuestionsTypes, g.Timer, g.NextQuestionOnTimer, g.EarliestYear)
	if _, err := db.ExecContext(ctx, sqlstr, g.ID, g.PackageSize, g.QuestionsTypes, g.Timer, g.NextQuestionOnTimer, g.EarliestYear); err != nil {
		return logerror(err)
	}
	// set exists
	g._exists = true
	return nil
}

// Update updates a Group in the database.
func (g *Group) Update(ctx context.Context, db DB) error {
	switch {
	case !g._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case g._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.groups SET ` +
		`package_size = $1, questions_types = $2, timer = $3, next_question_on_timer = $4, earliest_year = $5 ` +
		`WHERE id = $6`
	// run
	logf(sqlstr, g.PackageSize, g.QuestionsTypes, g.Timer, g.NextQuestionOnTimer, g.EarliestYear, g.ID)
	if _, err := db.ExecContext(ctx, sqlstr, g.PackageSize, g.QuestionsTypes, g.Timer, g.NextQuestionOnTimer, g.EarliestYear, g.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Group to the database.
func (g *Group) Save(ctx context.Context, db DB) error {
	if g.Exists() {
		return g.Update(ctx, db)
	}
	return g.Insert(ctx, db)
}

// Upsert performs an upsert for Group.
func (g *Group) Upsert(ctx context.Context, db DB) error {
	switch {
	case g._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.groups (` +
		`id, package_size, questions_types, timer, next_question_on_timer, earliest_year` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`package_size = EXCLUDED.package_size, questions_types = EXCLUDED.questions_types, timer = EXCLUDED.timer, next_question_on_timer = EXCLUDED.next_question_on_timer, earliest_year = EXCLUDED.earliest_year `
	// run
	logf(sqlstr, g.ID, g.PackageSize, g.QuestionsTypes, g.Timer, g.NextQuestionOnTimer, g.EarliestYear)
	if _, err := db.ExecContext(ctx, sqlstr, g.ID, g.PackageSize, g.QuestionsTypes, g.Timer, g.NextQuestionOnTimer, g.EarliestYear); err != nil {
		return logerror(err)
	}
	// set exists
	g._exists = true
	return nil
}

// Delete deletes the Group from the database.
func (g *Group) Delete(ctx context.Context, db DB) error {
	switch {
	case !g._exists: // doesn't exist
		return nil
	case g._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.groups ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, g.ID)
	if _, err := db.ExecContext(ctx, sqlstr, g.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	g._deleted = true
	return nil
}

// GroupByID retrieves a row from 'public.groups' as a Group.
//
// Generated from index 'groups_pk'.
func GroupByID(ctx context.Context, db DB, id int64) (*Group, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, package_size, questions_types, timer, next_question_on_timer, earliest_year ` +
		`FROM public.groups ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	g := Group{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&g.ID, &g.PackageSize, &g.QuestionsTypes, &g.Timer, &g.NextQuestionOnTimer, &g.EarliestYear); err != nil {
		return nil, logerror(err)
	}
	return &g, nil
}
